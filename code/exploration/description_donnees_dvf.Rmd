---
title: "Vue d'ensemble des données : Demandes de valeurs foncières 2021"
date: '05-12-2022'
output: 
  html_document:
    toc : true
    toc_depth : 4
    number_sections: true
    theme: readable
    highlight: tango
    toc_float:
      collapsed: false
      smooth_scroll: false
    css: style.css
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, eval = TRUE, message = FALSE, warning = FALSE)
```

```{r}
library(data.table)
library(magrittr)
library(DT)
library(ggplot2)
library(ggpubr)

dt <- fread("../data/data_dvf2021.csv")
N <- dt[, .N]
Ncol <- length(names(dt))
```

# Vue d'ensemble des variables
 
- Il y a au total `r N` lignes `r Ncol` colonnes ;
- Le fichier **notice-descriptive-du-fichier-dvf-20221017.pdf** qui est une documentation des données.

```{r}
# Class of variables
dt_class <- dt[, lapply( .SD, function(X) class(X) )]
dt_class <- data.table(variable = names(dt_class), class = t(dt_class)[, 1])
dt_class[, class := ifelse(grepl("_has_|_is_", variable), "logical", class)]

# %tage of NA
dt_na <- dt[, lapply(.SD, function(X) round(sum(is.na(X)) / .N * 100, 2))]
dt_na <- data.table(variable = names(dt_na), pourcentage_NA = t(dt_na)[, 1])

# Merge
dt_meta <- merge(x = dt_class, y = dt_na, by = "variable", all.x = TRUE)
rm(dt_na, dt_class)

# View datatable
datatable(dt_meta)
```
 
- Echantillon de 2000 dvf sur toute la France.
 
```{r fig.align='center', fig.height=5, fig.width=7}
samp <- sample(1:dt[, .N], 2000)
leaflet::leaflet() %>% 
     leaflet::addTiles() %>% 
     leaflet::setView(lng = 2.80, lat = 46.80, zoom = 5.1) %>% 
     leaflet::addCircleMarkers(lng = dt[samp, longitude],
                               lat = dt[samp, latitude], radius = 0)
```


## Variables identifiantes
```{r}
col_id <- c("id_mutation", "date_mutation", "adresse_numero", "adresse_suffixe", "adresse_code_voie", 
            "adresse_nom_voie", "code_postal", "code_commune", "nom_commune", "ancien_code_commune",
            "ancien_nom_commune", "code_departement", "id_parcelle", "ancien_id_parcelle", "numero_volume",
            "latitude", "longitude")
datatable(dt_meta[variable %in% col_id])
```


## Variables 'dates'
```{r}
col_date <- grep(pattern = "Date|date|annee", x = names(dt), value = TRUE)
datatable(dt_meta[variable %in% col_date])
```

# Variables qualitatives

# Nombre de modalités 
```{r}
# Number of modalitties per variable
col_char <- dt_meta[class == "character" & (! variable %in% col_id), variable]
dt_label <- rbindlist(lapply(col_char, function(col){
  lab <- dt[, get(col)]
  lab <- length(unique(lab))
  data.table(variable = col, nbr_modalites = lab)
}))
dt_meta_varqual <- merge(x = dt_meta, y = dt_label, by = "variable")
datatable(dt_meta_varqual)
```

## Quelques plots
 
- Les graphiques ci-dessous sont ceux des variables ayant au plus 4 modalités.
 
```{r}
col_varqual <- dt_meta_varqual[nbr_modalites <= 8, variable]
```

```{r fig.align='center', fig.height=5, fig.width=7}
col <- col_varqual[1]
n <- dt[! is.na(get(col)), .N]
  dt_x <- dt[! is.na(get(col)), .("pourcentage" = round(.N / n * 100, 2)), by = col]
ggplot(dt_x, aes(x = get(col), y = pourcentage)) + 
  geom_bar(stat = "identity", fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1))
```

```{r fig.align='center', fig.height=5, fig.width=7}
col <- col_varqual[2]
n <- dt[! is.na(get(col)), .N]
  dt_x <- dt[! is.na(get(col)), .("pourcentage" = round(.N / n * 100, 2)), by = col]
ggplot(dt_x, aes(x = get(col), y = pourcentage)) + 
    geom_bar(stat = "identity", fill="steelblue") + xlab("") + ggtitle(col) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```

**Exemple de traitement**
 
- Si on observe le graphique ci-dessus, on remarque qu'il y a plus ou moins 40% de type de local sans label.
- Comme on a le `code_type_local` dans la base de données, on peut procéder ainsi :
```{r echo=TRUE}
dt[, table(type_local, code_type_local)]
```

```{r echo=TRUE}
dt[, type_local := ifelse(code_type_local == 1, "Maison", 
                          ifelse(code_type_local == 2, "Appartement",
                                 ifelse(code_type_local == 3, "Dépendance",
                                        "Local industriel. commercial ou assimilé")))]
```

```{r fig.align='center', fig.height=5, fig.width=7}
col <- col_varqual[2]
n <- dt[! is.na(get(col)), .N]
  dt_x <- dt[! is.na(get(col)), .("pourcentage" = round(.N / n * 100, 2)), by = col]
ggplot(dt_x, aes(x = get(col), y = pourcentage)) + 
    geom_bar(stat = "identity", fill="steelblue") + xlab("") + ggtitle(col) +
    theme_minimal() +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1))
```


# Variables quantitatives

## Quelques statistiques
```{r}
col_num <- dt_meta[class == "numeric" & 
                     (! variable %in% c("Code commune", "Code postal",
                                        "Code type local",
                                        "No plan", "No voie", col_id)),
                   variable]
dt_summary <- rbindlist(lapply(col_num, function(col){
  x <- dt[, base::get(col)]
  data.table("variable" = col, "min" = min(x, na.rm = TRUE), 
             "q0.025" = round(quantile(x, 0.025, na.rm = TRUE), 2), 
             "q0.25" = round(quantile(x, 0.25, na.rm = TRUE), ), 
             "q0.5" = round(quantile(x, 0.5, na.rm = TRUE), 2), 
             "mean" = round(mean(x, na.rm = TRUE), 2),
             "q0.75" = round(quantile(x, 0.75, na.rm = TRUE), 2), 
             "q0.975" = round(quantile(x, 0.975, na.rm = TRUE), 2), 
             "max" = round(max(x, na.rm = TRUE), 2))
}))

DT::datatable(dt_summary)
```


## Quelques plots
 
- Histogramme et diagramme à moustache des variables quantitaves.
- NB : Dans certains cas, quelques valeurs extrêmes ont étés ignorées.
 
```{r gg_quanti, fig.align='center', fig.height=3.5, fig.width=8}
col <- col_num[1]
x <- dt[, base::get(col)]
x <- x[! is.na(x)]
dt_x <- data.table(x = x)
ghist <- ggplot(dt_x, aes(x = x)) + 
  geom_histogram(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()

gboxp <- ggplot(dt_x, aes(x = x)) + 
  geom_boxplot(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()
ggarrange(gboxp, ghist, ncol = 2)
```

```{r fig.align='center', fig.height=3.5, fig.width=8}
col <- col_num[2]
x <- dt[, base::get(col)]
x <- x[! is.na(x)]
dt_x <- data.table(x = x[! x >= quantile(x, 0.99)])
ghist <- ggplot(dt_x, aes(x = x)) + 
  geom_histogram(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()

gboxp <- ggplot(dt_x, aes(x = x)) + 
  geom_boxplot(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()
ggarrange(gboxp, ghist, ncol = 2)
```

```{r fig.align='center', fig.height=3.5, fig.width=8}
col <- col_num[3]
x <- dt[, base::get(col)]
x <- x[! is.na(x)]
dt_x <- data.table(x = x)
ghist <- ggplot(dt_x, aes(x = x)) + 
  geom_histogram(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()

gboxp <- ggplot(dt_x, aes(x = x)) + 
  geom_boxplot(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()
ggarrange(gboxp, ghist, ncol = 2)
```

```{r fig.align='center', fig.height=3.5, fig.width=8}
col <- col_num[4]
x <- dt[, base::get(col)]
x <- x[! is.na(x)]
dt_x <- data.table(x = x)
ghist <- ggplot(dt_x, aes(x = x)) + 
  geom_histogram(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()

gboxp <- ggplot(dt_x, aes(x = x)) + 
  geom_boxplot(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()
ggarrange(gboxp, ghist, ncol = 2)
```

```{r fig.align='center', fig.height=3.5, fig.width=8}
col <- col_num[5]
x <- dt[, base::get(col)]
x <- x[! is.na(x)]
dt_x <- data.table(x = x)
ghist <- ggplot(dt_x, aes(x = x)) + 
  geom_histogram(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()

gboxp <- ggplot(dt_x, aes(x = x)) + 
  geom_boxplot(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()
ggarrange(gboxp, ghist, ncol = 2)
```

```{r fig.align='center', fig.height=3.5, fig.width=8}
col <- col_num[6]
x <- dt[, base::get(col)]
x <- x[! is.na(x)]
dt_x <- data.table(x = x)
ghist <- ggplot(dt_x, aes(x = x)) + 
  geom_histogram(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()

gboxp <- ggplot(dt_x, aes(x = x)) + 
  geom_boxplot(fill="steelblue") + xlab("") + ggtitle(col) +
  theme_minimal()
ggarrange(gboxp, ghist, ncol = 2)
```

```{r}
rm(dt)
```

# La bdnb
 
La bdnd, c'est base de données nationale des bâtiments.
La base qui contient les tables au format csv (plus facile à explorer avec Python/R) a été téléchargée et ajouté dans le répertoire `_DATA/BaseNatBat`.
La documentation (dictionnaire) de la base est très bien faite, voir `_DATA/BaseNatBat/doc`.
 
En substance, la base a une structure en "entonnoir" :
 
- Niveau le plus détaillé : adresse des bâtiments et leur localisation géographique.
- Ensuite, on a des informations par groupe de bâtiments.
    + Il existe une table qui donne pour chaque bâtiment le groupe auquel il appartient.
    + Par groupe de bâtiments, il y a des informations sur topologie.
    + Par groupe de bâtiments, il y a des informations sur la consommation d'énergie : DPE, DLE, etc.
    + Par groupe de bâtiments, il y a des informations foncières : année de construction, nombre de logements, etc. Les autres informations étant "Accessible uniquement aux ayants droits DV3F". Etant donné que la base DVF précédemment décrite ne contient pas l'année de construction, on peut l'enrichir avec cette table de la bdnb.
- Aussi, pour chaque groupe de bâtiment on a des informations sur les parcelles comme la surface du sol, etc. Cette table peut être intéressante pour ajouter des éléments de contexte à un bâtiment.
- Enfin, par groupe de bâtiments, il y a des données sur les propriétaires de bâtiments.

# Jointure entre la bdnb et la dvf

Ici, on montre comment faire une jointure entre la bdnb et la base dvf.
 
- Dans la dvf, il y a un identifiant des parcelles.
- Dans la bdnd, il y a une table qui permet de faire la rélation entre chaque parcelle et les groupes de bâtiments qui lui sont asscociés. Cf. le fichier csv : **rel_batiment_groupe_parcelle.csv**.
- Ainsi, on peut faire une jointure entre la bdnb et la dvf à partir ce cette table.

```{r eval=FALSE, echo=TRUE}
# On charge les données
dt_dvf <- fread("../data/data_dvf2021.csv")
dt_bdnb_parcelle_bat <- fread("../data/open_data_v072_France_csv/csv/rel_batiment_groupe_parcelle.csv")

# On merge
dt <- merge(x = dt_dvf, y = dt_bdnb_parcelle_bat, by.x = "id_parcelle", by.y = "parcelle_id")
```







