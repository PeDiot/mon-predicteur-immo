---
title: "Exploration données valeurs foncières"
author: "Pierre-Emmanuel Diot"
date: "2023-01-09"
output: 
  html_document: 
    toc: true
    toc_float: true
editor_options: 
  chunk_output_type: console
params: 
  file_name: datadvf2022.csv
---

<style type="text/css">
.twoC {width: 100%}
.clearer {clear: both}
.twoC .table {max-width: 50%; float: right}
.twoC img {max-width: 50%; float: left}
</style>


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, 
                      message = FALSE, 
                      comment = FALSE, 
                      warning = FALSE, 
                      fig.align = "center", 
                      fig.height = 3.5, 
                      fig.width = 4)

# setwd("C:/Users/pemma/OneDrive - GENES/Ensae/Business Data Challenge/Code/Exploration"
```

```{r packages}
library(rmarkdown)

library(tidyverse)
library(data.table)
library(DT)

library(naniar)
library(questionr)

library(kableExtra)

library(shiny)
library(plotly)
library(leaflet)
library(RColorBrewer)

theme_set(theme_minimal())
```

```{r dir}
DIR <- getwd()
DATA_DIR <- "../../Data/DVF/"
```

```{r functions}
source("functions.R", encoding = "UTF-8")
```

## Data

```{r cache=TRUE, include=FALSE}
system.time(
  dat <- fread(input = paste0(DATA_DIR, params$file_name), 
               encoding = "UTF-8" 
               # ,na.strings = c("", NA)
               )
)
```

```{r}
dat %>% 
  head(n = 10) %>% 
  mykable(title = "Aperçu de la base de données") %>% 
  scroll_box(width = "100%", box_css = "border: 0px;")
```

### Visualisation géographique

```{r}
samp <- dat %>%
  filter(rownames(.) %in% sample(x = 1:nrow(dat), size = 2000)) 

leaflet() %>% 
     addTiles() %>% 
     setView(lng = 2.80, lat = 46.80, zoom = 5.1) %>% 
     addCircleMarkers(
       lng = samp$longitude,
       lat = samp$latitude, 
       radius = 0)
```

### Données manquantes

```{r missing}
missing <- dat %>% 
  freq.na() %>% 
  as.data.frame() 

vars_with_nans <- missing %>% 
  dplyr::filter(missing > 0) %>% rownames()

p <- dat %>%
  select(all_of(vars_with_nans)) %>% 
  gg_miss_var(show_pct = T) +
  labs(x = "") 
```


:::: {style="display: flex;"}

::: {}
```{r }
missing %>% 
  dplyr::filter(missing > 0) %>%
  datatable()
```
:::

::: {}

```{r fig.height=5}
p %>% ggplotly()
```
:::

::::

### Variables identifiantes

```{r}
col_id <- c(
  "id_mutation",
  "date_mutation",
  "adresse_numero",
  "adresse_suffixe",
  "adresse_code_voie",
  "adresse_nom_voie", 
  "code_postal", 
  "code_commune",
  "nom_commune", 
  "ancien_code_commune",
  "ancien_nom_commune", 
  "code_departement",
  "id_parcelle",
  "ancien_id_parcelle", 
  "numero_volume",
  "latitude", 
  "longitude"
)

dat_id <- dat %>% dplyr::select(all_of(col_id))
```

```{r}
make_structure_table(dat_id, missing) %>% datatable()
```

### Variables catégorielles

#### Description

```{r}
dat_cat <- dat %>%
  dplyr::select(where(is.character)) %>% 
  dplyr::select(-one_of(col_id)) %>% 
  mutate(nombre_pieces_principales = dat %>% pull(nombre_pieces_principales)) %>% 
  unclass() %>% 
  as.data.frame(stringsAsFactors = T)  
```

```{r}
make_structure_table(dat_cat, missing) %>% datatable()
```

#### Répartition par niveau

```{r}
n_vars <- ncol(dat_cat)
colors <- brewer.pal(n_vars, "Set3")

plot_list <- list()
for (i in 1:n_vars){
  var_name <- colnames(dat_cat)[i]
  n_levels <- nlevels(dat_cat[[var_name]])
  
  if (missing[var_name, "%"] < 100 & n_levels < 30) 
    plot_list[[var_name]]<- make_pct_countplot(var_name = var_name, color = colors[i])
  
}
```

:::: {style="display: flex;"}

::: {}
```{r }
plot_list$nature_mutation
```
:::

::: {}

```{r }
plot_list$type_local
```
:::

::::


:::: {style="display: flex;"}

::: {}
```{r }
plot_list$code_nature_culture
```
:::

::: {}

```{r }
plot_list$nature_culture
```
:::

::::

<center>

```{r}
plot_list$nombre_pieces_principales
```

</center>

### Variables quantitatives

```{r}
col_quanti <- c(
  "valeur_fonciere", 
  "surface_reelle_bati", 
  "surface_terrain", 
  "lot1_surface_carrez", 
  "lot2_surface_carrez", 
  "lot3_surface_carrez", 
  "lot4_surface_carrez", 
  "lot5_surface_carrez")

dat_quanti <- dat %>% dplyr::select(all_of(col_quanti))
```

#### Description

```{r}
make_structure_table(dat_quanti, missing) %>% datatable()
```

#### Distribution par variable

```{r}
stats_quanti <- sapply(
  
  X = col_quanti, 
  FUN = function(var_name) {
   x <- dat_quanti %>% pull(var_name)
   stat_table(x, var_name)
  }, 
  
  USE.NAMES = T, 
  simplify = F
) 

stats_quanti_tab <- stats_quanti %>%
  bind_rows() %>% 
  filter(rownames(.) != "valeur_fonciere") %>% 
  mutate_if(is.numeric, funs(format(., big.mark = " ", scientific = F, digits = 2)))
```


```{r statsquantitab}
stats_quanti_tab %>% 
  mykable(title = "Résumé statistique des variables quantitatives")
```

On remarque que l'étendue de la distribution des différentes variables quantitative est importante. Pour représenter leurs histogrammes de sélectionner les valeurs inférieures ou égales au 3ème quantile de chaque série. 

```{r}
n_vars <- ncol(dat_quanti)
colors <- brewer.pal(n_vars, "Set3")

plot_list <- list()
for (i in 1:n_vars) {
  
  var_name <- col_quanti[i]
  thresold <- stats_quanti[[var_name]][var_name, "Q75%"]
  color <- colors[i]
  
  plot_list[[var_name]] <- make_histogram(var_name = var_name, thresold = thresold, color = color)

}
```

:::: {style="display: flex;"}

::: {}
```{r }
plot_list$surface_reelle_bati
```
:::

::: {}

```{r }
plot_list$surface_terrain
```
:::

::::

:::: {style="display: flex;"}

::: {}
```{r }
plot_list$lot1_surface_carrez
```
:::

::: {}

```{r }
plot_list$lot2_surface_carrez
```
:::

::::

:::: {style="display: flex;"}

::: {}
```{r }
plot_list$lot3_surface_carrez
```
:::

::: {}

```{r }
plot_list$lot4_surface_carrez
```
:::

::::


#### Variable cible


```{r }
stats_quanti$valeur_fonciere %>% 
  mutate_if(is.numeric, funs(format(., big.mark = " ", scientific = F, digits = 2))) %>% 
  mykable(title = "Résumé statistique de la variable cible")
```

<center>

```{r}
plot_list$valeur_fonciere
```

</center>

## Analyse statistique 

### Valeurs abberantes (outliers)

La table \@ref(tab:statsquantitab) indique des disparités importantes au sein de chaque variable quantitative. L'objectif est d'identifier les valeurs aberrantes à l'aide d'une méthode statistique. On décide d'utiliser le filtre d'Hampel qui classe comme outliers les valeurs situés en dehors de l'intervalle $I$ défini comme suit :

$$
I = [\tilde{X} - 3\times \text{MAD} ; \tilde{X} + 3\times \text{MAD}] \quad \text{avec MAD}= \text{median}(|X_i - \tilde{X}|)
$$
où $\tilde{X}$ est la médiane de la série $X$ et $\text{MAD}$ l'écart absolu médian.

```{r}
outliers <- sapply(
  X = col_quanti, 
  FUN = function(var_name) dat %>% pull(var_name) %>% hampel_filter
)

n <- nrow(dat) 

outliers_freqs <- sapply(
  X = outliers, 
  FUN = function(x) length(x) / n
 ) %>% 
  bind_rows() %>%
  t() %>% 
  as.data.frame() %>% 
  rename(`%` = V1)

outliers_freqs %>% 
  arrange(desc(`%`)) %>% 
  mutate_if(is.numeric, funs(format(100 * ., big.mark = " ", scientific = F, digits = 2))) %>% 
  mykable(title = "Proportion d'outliers par variable")

```


## Modélisation 